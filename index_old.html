<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="manifest" href="site.webmanifest">
        <link rel="apple-touch-icon" href="icon.png">
        <!-- Place favicon.ico in the root directory -->

        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
    </head>
    <body>
        <!--[if lte IE 9]>
            <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
        <![endif]-->

        <script src='js/libs/three/inflate.min.js'></script>
        <script src="js/libs/three/three.js"></script>

        <script src="js/libs/three/OrbitControls.js"></script>

        <script src="js/libs/three/VTKLoader.js"></script>
        <script src="js/libs/three/PLYLoader.js"></script>

        <script src="js/libs/three/Detector.js"></script>
        <script src="js/libs/three/stats.min.js"></script>

        <script id="vertexShader" type="x-shader/x-vertex">

varying vec2 vUv;
varying vec3 vecPos;
varying vec3 vecNormal;

attribute float alphaValue;
varying float vAlphaValue;
attribute float highlightValue;
varying float vHighlightValue;

void main() {
  vUv = uv;
  // Since the light is in camera coordinates,
  // I'll need the vertex position in camera coords too
  vecPos = (modelViewMatrix * vec4(position, 1.0)).xyz;
  // That's NOT exacly how you should transform your
  // normals but this will work fine, since my model
  // matrix is pretty basic
  vecNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;
  gl_Position = projectionMatrix *
                vec4(vecPos, 1.0);

  vAlphaValue = alphaValue;
  vHighlightValue = highlightValue;
}
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

varying vec2 vUv;
varying vec3 vecPos;
varying vec3 vecNormal;

varying float vAlphaValue;
varying float vHighlightValue;

uniform float lightIntensity;
uniform sampler2D textureSampler;

struct PointLight {
  vec3 color;
  vec3 position; // light position, in camera coordinates
  float distance; // used for attenuation purposes. Since
                  // we're writing our own shader, it can
                  // really be anything we want (as long as
                  // we assign it to our light in its
                  // "distance" field
};

uniform PointLight pointLights[NUM_POINT_LIGHTS];

void main(void) {
  // Pretty basic lambertian lighting...
  vec4 addedLights = vec4(0.0,
                          0.0,
                          0.0,
                          1.0);
  for(int l = 0; l < NUM_POINT_LIGHTS; l++) {
      vec3 lightDirection = normalize(vecPos
                            - pointLights[l].position);
      addedLights.rgb += clamp(dot(-lightDirection,
                               vecNormal), 0.0, 1.0)
                         * pointLights[l].color
                         * lightIntensity;
  }
  gl_FragColor = texture2D(textureSampler, vUv)
                 * addedLights;

  //gl_FragColor = vec4(0.0, 0.0, 1.0, 0.5);

  gl_FragColor.r = vHighlightValue;
  gl_FragColor.a = vAlphaValue;
}
        </script>

        <script>

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container, stats;

            var camera, controls, scene, renderer, brain;

            var cross;

            init();
            animate();

            function init() {

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );
                camera.position.set(0.1, 0.1, 0.1);

                controls = new THREE.OrbitControls( camera );
;
                controls.noZoom = false;
                controls.noPan = false;

                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;

                scene = new THREE.Scene();

                scene.add( camera );

                // light

                /*var scale = 1;
                for (x = -1; x <= 1; x += 2) {
                    for (y = -1; y <= 1; y += 2) {
                        for (z = -1; z <= 1; z += 2) {
                            var light = new THREE.PointLight( 0xffffff, 0.3 );
                            light.position.set( scale*x, scale*y, scale*z );
                            scene.add( light );
                        }
                    }
                }*/
                var light = new THREE.PointLight( 0xffffff, 1 );
                light.position.set( 10, 0, 0 );

                camera.add( light );
                camera.add( light.target );

                var material = new THREE.MeshPhongMaterial( { color: 0xffffff, side: THREE.DoubleSide } );

                material = new THREE.ShaderMaterial({
                    uniforms: THREE.UniformsUtils.merge([
                        THREE.UniformsLib['lights'],
                        {
                            lightIntensity: {type: 'f', value: 1200000000.0},
                            textureSampler: {type: 't', value: null}
                        }
                    ]),
                    vertexShader: document.
                    getElementById('vertexShader').text,
                    fragmentShader: document.
                    getElementById('fragmentShader').text,
                    transparent: true,
                    lights: true
                });

                var scale = 0.000000001;
                var texture = new THREE.TextureLoader().load('img/brain_texture.jpg');
                material.uniforms.textureSampler.value = texture;

                var loader = new THREE.VTKLoader();

                loader.load( "models/jubrain-mpm-surf.vtk", function ( geometry ) {

                    geometry.center();
                    geometry.computeVertexNormals();

                    brain = new THREE.Mesh( geometry, material );
                    brain.rotation.set(-Math.PI/2, 0, 0);
                    brain.scale.multiplyScalar( scale );
                    scene.add( brain );
                    console.log(brain);
                } );


                // renderer

                renderer = new THREE.WebGLRenderer( { antialias: false } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );

                container = document.createElement( 'div' );
                document.body.appendChild( container );
                container.appendChild( renderer.domElement );

                stats = new Stats();
                container.appendChild( stats.dom );

                //

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                controls.handleResize();

            }

            function animate() {

                requestAnimationFrame( animate );

                controls.update();
                renderer.render( scene, camera );

                stats.update();

            }

        </script>

        <script>

            function highlightSection() {

                var geometry = brain.geometry;
                var alphaArray = [];
                var highlightArray = [];
                var numVertices = geometry.attributes.position.array.length / 3;
                var max = 0;
                for(var i = 0; i < numVertices; i++) {
                    var x = geometry.attributes.position.array[3*i];
                    var y = geometry.attributes.position.array[3*i+1];
                    var z = geometry.attributes.position.array[3*i+2];
                    var d = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
                    if (d > max) max = d;
                    alphaArray.push(0.5);

                    if (d/91268514 > 0.6) {
                        highlightArray.push(0);
                    } else {
                        highlightArray.push(1);
                    }
                }
                geometry.addAttribute('alphaValue', new THREE.BufferAttribute(new Float32Array(alphaArray), 1));
                geometry.addAttribute('highlightValue', new THREE.BufferAttribute(new Float32Array(highlightArray), 1));
                console.log(d);

            }

        </script>

        <button style="position: absolute; right:0; top:0;" onclick="highlightSection()">Go</button>

        <script src="js/vendor/modernizr-3.5.0.min.js"></script>
        <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
        <script>window.jQuery || document.write('<script src="js/vendor/jquery-3.2.1.min.js"><\/script>')</script>
        <script src="js/plugins.js"></script>
        <script src="js/main.js"></script>


        <!-- Google Analytics: change UA-XXXXX-Y to be your site's ID. -->
        <script>
            window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
            ga('create','UA-XXXXX-Y','auto');ga('send','pageview')
        </script>
        <script src="https://www.google-analytics.com/analytics.js" async defer></script>
    </body>
</html>
